title: "正则表达式"
date: 2015-05-11 15:18:23
tags: [js,note]
---
##基本方法

* RegExp
主要有`test()`和`exec()`两个方法。
    * `test()`：如果给定字符串匹配这个模式，返回true，反之亦然。
    * `exec()`：返回一个数组，数组中的第一个条目是第一个匹配；其他是反向引用。
* String
主要有`match()`和`search()`，另外`replace()`和`split()`也支持正则作为传入参数。
    * `match()`：返回一个包含字符串中所有匹配的数组，其他是反向引用。
    * `search()`：返回字符串中出现的第一个匹配的位置，然而全局匹配正则表达式在`search()`时并不起作用。
    * `replace()`和`split()`都支持正则的匹配。
    
##简单模式
* 元字符
有`(`、`[`、`{`、`\`、`^`、`$`、`|`、`)`、`?`、`*`、`+`、`.`。需要用`\`进行转义，在非字面量表示的时候所有的反斜杠要用两个反斜杠来替换。

* 简单类
`/[bcf]at/`匹配所有的`bat`、`cat`和`fat`。

* 负向类
`/[^bc]at/`匹配所有含有`at`但是不以`b`和`c`开头的字符串。

* 范围类
`[a-z]`表示所有小写字母，`[num[1-4]]`这样的形式很方便。

* 组合类
是有集中其他的类组合而成的字符类。

* 量词
    * `{n,m}`表示至少n次，至多m次
    * `?`等价于`{0,1}`
    * `*`等价于`{0,}`
    * `+`等价于`{1,}`
    * `{n}`等价于`{n,n}`


##复杂模式
通过分组、反向引用、前瞻等一些强大的正则表达式功能，可以方便地使用正则表达式进行复杂的字符串操作。

* 分组
        
        var str = "dogdog";
        var regDog = /(dog)+/;
        str.match(regDog);
可以匹配字符串中多次出现的`dog`。并且，分组可以嵌套，通过嵌套和不同的组合可以实现复杂的分组。

* 反向引用

在表达式计算完成后，每个分组都被存放在一个特殊的地方以备将来使用，这些存储在分组中的特殊值，我们称之为反向引用。反向引用是按照从左到右的左括号字符的顺序进行创建和编号的。
例如，`(A?(B?(C?)))`将包含三个反向引用：`(A?(B?(C?)))`、`(B?(C?))`、`(C?)`。

反向引用主要有三种使用方式。

1. reg.$1
        
        var str = "dagdbgdcg"
        var reg = /(dag)(dbg)(dcg)/;
        str.match(reg);
        console.log(RegExp.$1);
        
2. /(reg)\1/

        var str = "dagdagdog"
        var reg = /(dag)\1/;
        str.match(reg);
        console.log(RegExp.$1);
        
3. replace(reg,"$2 $1")

        var str = "1234 2345"
        var reg = /(\d{4}) (\1)/;
        var newStr = str.replace(reg, "$2 $1");

这里需要注意的是对于2种的`\1`的使用，是匹配出来的值，而不是匹配方式。另外，在左括号后加上`?:`可以创建非捕获分组，即可不存储反向引用的结果。

* 候选
`|`是正则表达式的候选操作符。

        var str = "蛤蛤和长者";
        var reg = /蛤蛤|长者/g;
        str = str.replace(reg,"*****");
        
        var str = "蛤蛤和长者";
        var reg = /蛤蛤|长者/g;
        //这里的sMatch是reg匹配到的结果数组中的元素
        str = str.replace(reg,function(sMatch){return sMatch.replace(/./g,"*")});
        
* 前瞻
    * 正向前瞻`bed(?=room)`表示查询*接下来*出现的*是*括号中的内容
    * 负向前瞻`room(?！red)`表示查询*接下来*出现的*不是*括号中的内容。
    * 并且，前瞻不会出现在反向引用的结果中，分组不会考虑前瞻的存在。

* 边界
    `^`:行开头
    `$`:行结尾
    `\b`:单词边界
    `\B`:非单词的边界

* 多行模式
`/m`表示多行模式，多行模式会改变`^`和`$`的边界行为，是的`\n`前后也为边界。

    
